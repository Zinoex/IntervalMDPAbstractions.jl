var documenterSearchIndex = {"docs":
[{"location":"reference/dynamics/#Dynamics","page":"Dynamics","title":"Dynamics","text":"","category":"section"},{"location":"reference/dynamics/#General","page":"Dynamics","title":"General","text":"","category":"section"},{"location":"reference/dynamics/","page":"Dynamics","title":"Dynamics","text":"DiscreteTimeStochasticDynamics\ndimstate\ndiminput\nSystem\ndynamics\ninitial","category":"page"},{"location":"reference/dynamics/#IntervalMDPAbstractions.DiscreteTimeStochasticDynamics","page":"Dynamics","title":"IntervalMDPAbstractions.DiscreteTimeStochasticDynamics","text":"DiscreteTimeStochasticDynamics\n\nAbstract type for discrete-time stochastic dynamicss, i.e. x_k+1 = f(x_k u_k w_k).\n\n\n\n\n\n","category":"type"},{"location":"reference/dynamics/#IntervalMDPAbstractions.dimstate","page":"Dynamics","title":"IntervalMDPAbstractions.dimstate","text":"dimstate(dyn::DiscreteTimeStochasticDynamics)\n\nReturn the dimension of the state space of the dynamics dyn.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#IntervalMDPAbstractions.diminput","page":"Dynamics","title":"IntervalMDPAbstractions.diminput","text":"diminput(dyn::DiscreteTimeStochasticDynamics)\n\nReturn the dimension of the input space of the dynamics dyn.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#IntervalMDPAbstractions.System","page":"Dynamics","title":"IntervalMDPAbstractions.System","text":"System{D<:DiscreteTimeStochasticDynamics, I<:LazySet}\n\nA struct representing a system with dynamics and an initial set.\n\n\n\n\n\n","category":"type"},{"location":"reference/dynamics/#IntervalMDPAbstractions.dynamics","page":"Dynamics","title":"IntervalMDPAbstractions.dynamics","text":"dynamics(sys::System)\n\nReturn the dynamics of the system.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#IntervalMDPAbstractions.initial","page":"Dynamics","title":"IntervalMDPAbstractions.initial","text":"initial(sys::System)\n\nReturn the initial set of the system.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#Additive-noise-systems","page":"Dynamics","title":"Additive noise systems","text":"","category":"section"},{"location":"reference/dynamics/","page":"Dynamics","title":"Dynamics","text":"AdditiveNoiseDynamics\nnominal\nprepare_nominal\nnoise\nAffineAdditiveNoiseDynamics\nNonlinearAdditiveNoiseDynamics\nUncertainPWAAdditiveNoiseDynamics\nUncertainAffineRegion","category":"page"},{"location":"reference/dynamics/#IntervalMDPAbstractions.AdditiveNoiseDynamics","page":"Dynamics","title":"IntervalMDPAbstractions.AdditiveNoiseDynamics","text":"AdditiveNoiseDynamics\n\nDynamics with additive noise, i.e. x_k+1 = f(x_k u_k) + w_k with some i.i.d. noise structure w_k.\n\n\n\n\n\n","category":"type"},{"location":"reference/dynamics/#IntervalMDPAbstractions.nominal","page":"Dynamics","title":"IntervalMDPAbstractions.nominal","text":"nominal\n\nCompute the reachable set under the nominal dynamics of the dynamics dyn over the state region X and control u. The nominal dynamics are given by hatx_k+1 = f(x_k u_k), which implies that nominal dynamics are only well-defined for additive noise dynamics. Since for some non-linear dynamics, no analytical formula exists for the one-step reachable set under the nominal dynamics, the function nominal only guarantees that the returned set is a superset of the one-step true reachable set, i.e. an over-approximation.\n\nNote that for NonlinearAdditiveNoiseDynamics, you must first call prepare_nominal before calling nominal. If the method is called with a single state x::Vector{<:Real}, it is not necessary to call prepare_nominal first.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#IntervalMDPAbstractions.prepare_nominal","page":"Dynamics","title":"IntervalMDPAbstractions.prepare_nominal","text":"prepare_nominal\n\nThe need for this method is a result of using TaylorModels.jl for the over-approximation of the reachable set under non-linear nominal dynamics. This package relies on global variables to store the variables of the Taylor models, which can be problematic when using multi-threading. Furthermore, when setting the variables, it invalidates existing Taylor models. Therefore, before entering the loop of abstraction to compute the transition probability bounds for all regions, we call this method to set up the global state appropriately.\n\nThis method is a no-op for dynamics that are not NonlinearAdditiveNoiseDynamics.\n\nEventually, we hope to remove the need for this method by using a more thread-safe library for Taylor models, e.g. akin to MultivariatePolynomials.jl.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#IntervalMDPAbstractions.noise","page":"Dynamics","title":"IntervalMDPAbstractions.noise","text":"noise\n\nFor additive dynamics x_k+1 = f(x_k u_k) + w_k, return w_k as a struct. See AdditiveNoiseStructure for implementations.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#IntervalMDPAbstractions.AffineAdditiveNoiseDynamics","page":"Dynamics","title":"IntervalMDPAbstractions.AffineAdditiveNoiseDynamics","text":"AffineAdditiveNoiseDynamics\n\nA struct representing dynamics with additive noise. That is, x_k+1 = A x_k + B u_k + C + w_k, where w_k  p_w and p_w is multivariate probability distribution.\n\nFields\n\nA::AbstractMatrix{Float64}: The linear state matrix.\nB::AbstractMatrix{Float64}: The control input matrix.\nC::AbstractMatrix{Float64}: The constant drift vector.\nw::AdditiveNoiseStructure: The additive noise.\n\nExamples\n\nA = [1.0 0.1; 0.0 1.0]\nB = [0.0; 1.0]\n\nw_stddev = [0.1, 0.1]\nw = AdditiveDiagonalGaussianNoise(w_stddev)\n\n# If no C is provided, it is assumed to be zero.\ndyn = AffineAdditiveNoiseDynamics(A, B, w)\n\n\n\n\n\n","category":"type"},{"location":"reference/dynamics/#IntervalMDPAbstractions.NonlinearAdditiveNoiseDynamics","page":"Dynamics","title":"IntervalMDPAbstractions.NonlinearAdditiveNoiseDynamics","text":"NonlinearAdditiveNoiseDynamics\n\nA struct representing dynamics with additive noise. That is, x_k+1 = f(x_k u_k) + w_k, where w_k sim p_w and p_w is multivariate probability distribution.\n\nnote: Note\nThe nominal dynamics of this class are assumed to be infinitely differentiable, i.e.  the Taylor expansion of the dynamics function f is well-defined. This is because to over-approximate the one-step reachable set, we rely on Taylor models, which are Taylor expansions + a remainder term. If you are dealing wit a non-differentiable dynamics function, consider using UncertainPWAAdditiveNoiseDynamics instead. To obtain an UncertainPWAAdditiveNoiseDynamics, you can partitoned the state space and use Linear Bound Propagation with each region (see bound_propagation).\n\nwarning: Warning\nBefore calling nominal with a LazySet as input, you must call prepare_nominal.  This is because the TaylorSeries.jl package modifies its global state. If you are using multi-threading, prepare_nominal must be called before entering the threaded section.\n\nFields\n\nf::Function: A function taking x::Vector and u::Vector as input and returns a Vector of the dynamics output.\nnstate::Int: The state dimension.\nninput::Int: The input dimension.\nw::AdditiveNoiseStructure: The additive noise.\n\nExamples\n\n\n# Stochastic Van der Pol Oscillator with additive uniform noise, but no inputs.\nτ = 0.1\nf(x, u) = [x[1] + x[2] * τ, x[2] + (-x[1] + (1 - x[1])^2 * x[2]) * τ]\n\nw_stddev = [0.1, 0.1]\nw = AdditiveDiagonalUniformNoise(w_stddev)\n\ndyn = NonlinearAdditiveNoiseDynamics(f, 2, 0, w)\n\n\n\n\n\n","category":"type"},{"location":"reference/dynamics/#IntervalMDPAbstractions.UncertainPWAAdditiveNoiseDynamics","page":"Dynamics","title":"IntervalMDPAbstractions.UncertainPWAAdditiveNoiseDynamics","text":"UncertainPWAAdditiveNoiseDynamics\n\nA struct representing uncertain PWA dynamics with additive noise. That is, x_k+1 = A_iu(alpha) x_k + C_iu(alpha) + w_k, where x_k in X_i is the state,  A_iu(alpha) = alpha underlineA_iu + (1 - alpha) overlineA_iu and  C_iu(alpha) = alpha underlineC_iu + (1 - alpha) overlineC_iu with alpha in 0 1 is the dynamics for region X_i under control action u, and w_k sim p_w is the additive noise where p_w is multivariate probability distribution.\n\nFields\n\ndimstate::Int: The dimension of the state space.\ndynregions::Vector{Vector{<:UncertainAffineRegion}: A list (action) of lists (regions) of UncertainAffineRegion to represent the uncertain PWA dynamics.\nw::AdditiveNoiseStructure: The additive noise.\n\n\n\n\n\n","category":"type"},{"location":"reference/dynamics/#IntervalMDPAbstractions.UncertainAffineRegion","page":"Dynamics","title":"IntervalMDPAbstractions.UncertainAffineRegion","text":"UncertainAffineRegion\n\nA struct representing an uncertain affine transition, valid over a region. That is, A(alpha) x + C(alpha) where A(alpha) = alpha underlineA + (1 - alpha) overlineA and C(alpha) = alpha underlineC + (1 - alpha) overlineC for alpha in 0 1, valid over a region X.\n\nFields\n\nregion::LazySet{Float64}: The region over which the affine transition is valid.\nAlower::AbstractMatrix{Float64}: The linear lower bound matrix.\nClower::AbstractVector{Float64}: The constant lower bound vector.\nAupper::AbstractMatrix{Float64}: The linear upper bound matrix.\nCupper::AbstractVector{Float64}: The constant upper bound vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/dynamics/#Additive-noise-structures","page":"Dynamics","title":"Additive noise structures","text":"","category":"section"},{"location":"reference/dynamics/","page":"Dynamics","title":"Dynamics","text":"AdditiveNoiseStructure\nAdditiveDiagonalGaussianNoise\nAdditiveCentralUniformNoise","category":"page"},{"location":"reference/dynamics/#IntervalMDPAbstractions.AdditiveNoiseStructure","page":"Dynamics","title":"IntervalMDPAbstractions.AdditiveNoiseStructure","text":"AdditiveNoiseStructure\n\nStructure to represent the noise of additive noise dynamics. See AdditiveDiagonalGaussianNoise and AdditiveCentralUniformNoise for concrete types.\n\n\n\n\n\n","category":"type"},{"location":"reference/dynamics/#IntervalMDPAbstractions.AdditiveDiagonalGaussianNoise","page":"Dynamics","title":"IntervalMDPAbstractions.AdditiveDiagonalGaussianNoise","text":"AdditiveDiagonalGaussianNoise\n\nAdditive diagonal Gaussian noise structure with zero mean, i.e. w_k sim mathcalN(0 mathrmdiag(sigma)). Zero mean is without loss of generality, since the mean can be absorbed into the nominal dynamics.\n\n\n\n\n\n","category":"type"},{"location":"reference/dynamics/#IntervalMDPAbstractions.AdditiveCentralUniformNoise","page":"Dynamics","title":"IntervalMDPAbstractions.AdditiveCentralUniformNoise","text":"AdditiveCentralUniformNoise\n\nAdditive diagonal uniform noise structure, i.e. w_k sim mathcalU(-r r).  This is without loss of generality, since the mean can be absorbed into the nominal dynamics. That is, w_k sim mathcalU(a b) is equivalent to c + w_k where w_k sim mathcalU(-r r) with c = (a + b)  2 and r = (b - a)  2, such that c can be absorbed into the nominal dynamics.\n\n\n\n\n\n","category":"type"},{"location":"reference/dynamics/#Abstracted-Gaussian-processes","page":"Dynamics","title":"Abstracted Gaussian processes","text":"","category":"section"},{"location":"reference/dynamics/","page":"Dynamics","title":"Dynamics","text":"AbstractedGaussianProcess\nAbstractedGaussianProcessRegion\ngp_bounds\nregion\nmean_lower\nmean_upper\nstddev_lower\nstddev_upper","category":"page"},{"location":"reference/dynamics/#IntervalMDPAbstractions.AbstractedGaussianProcess","page":"Dynamics","title":"IntervalMDPAbstractions.AbstractedGaussianProcess","text":"AbstractedGaussianProcess\n\nA struct representing bounds on the mean and stddev of a Gaussian process for each region over a partitioned space.\n\nFields\n\ndyn::Vector{Vector{<:AbstractedGaussianProcessRegion}}: A list (action) of lists (regions) of AbstractedGaussianProcessRegion`.\n\n\n\n\n\n","category":"type"},{"location":"reference/dynamics/#IntervalMDPAbstractions.AbstractedGaussianProcessRegion","page":"Dynamics","title":"IntervalMDPAbstractions.AbstractedGaussianProcessRegion","text":"AbstractedGaussianProcessRegion\n\nA struct representing an bounds on the mean and stddev of a Gaussian process over a region X_i. That is, underlinemu_i leq mu(x) leq overlinemu_i and  underlineSigma_ill leq Sigma(x)_ill leq overlineSigma_ill for all x in X_i and each axis l.\n\nFields\n\nregion::LazySet{Float64}: The region over which the affine transition is valid.\nmean_lower::AbstractVector{Float64}: The linear lower bound vector.\nmean_upper::AbstractVector{Float64}: The constant lower bound vector.\nstddev_lower::AbstractVector{Float64}: The linear upper bound vector.\nstddev_upper::AbstractVector{Float64}: The constant upper bound vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/dynamics/#IntervalMDPAbstractions.gp_bounds","page":"Dynamics","title":"IntervalMDPAbstractions.gp_bounds","text":"gp_bounds(dyn::AbstractedGaussianProcess, X::LazySet, input::Int)\n\nReturn the bounds on the mean and stddev of the Gaussian process for a given state region X and control action input.  The return type is an AbstractedGaussianProcessRegion.\n\nIf the state region is not in the domain of the dynamics, an ArgumentError is thrown.\n\n\n\n\n\ngp_bounds(dyn::AbstractedGaussianProcess, x::Vector{<:Real}, input::Int)\n\nReturn the bounds on the mean and stddev of the Gaussian process for a given state x and control action input. The return type is an AbstractedGaussianProcessRegion.\n\nIf the state is not in the domain of the dynamics, an ArgumentError is thrown.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#IntervalMDPAbstractions.region","page":"Dynamics","title":"IntervalMDPAbstractions.region","text":"region(abstracted_region::AbstractedGaussianProcessRegion)\n\nReturn the region over which the Gaussian process bounds are valid.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#IntervalMDPAbstractions.mean_lower","page":"Dynamics","title":"IntervalMDPAbstractions.mean_lower","text":"mean_lower(abstracted_region::AbstractedGaussianProcessRegion, i)\n\nReturn the lower bound on the mean of the Gaussian process for axis i.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#IntervalMDPAbstractions.mean_upper","page":"Dynamics","title":"IntervalMDPAbstractions.mean_upper","text":"mean_upper(abstracted_region::AbstractedGaussianProcessRegion, i)\n\nReturn the upper bound on the mean of the Gaussian process for axis i.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#IntervalMDPAbstractions.stddev_lower","page":"Dynamics","title":"IntervalMDPAbstractions.stddev_lower","text":"stddev_lower(abstracted_region::AbstractedGaussianProcessRegion, i)\n\nReturn the lower bound on the stddev of the Gaussian process for axis i.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#IntervalMDPAbstractions.stddev_upper","page":"Dynamics","title":"IntervalMDPAbstractions.stddev_upper","text":"stddev_upper(abstracted_region::AbstractedGaussianProcessRegion, i)\n\nReturn the upper bound on the stddev of the Gaussian process for axis i.\n\n\n\n\n\n","category":"function"},{"location":"reference/dynamics/#Stochastic-switched-systems","page":"Dynamics","title":"Stochastic switched systems","text":"","category":"section"},{"location":"reference/dynamics/","page":"Dynamics","title":"Dynamics","text":"StochasticSwitchedDynamics","category":"page"},{"location":"reference/dynamics/#IntervalMDPAbstractions.StochasticSwitchedDynamics","page":"Dynamics","title":"IntervalMDPAbstractions.StochasticSwitchedDynamics","text":"StochasticSwitchedDynamics\n\nA type that represents dynamics with a stochastic transition between the modes. When abstracting stochastic switched dynamics, the transition probability bounds are computed individually for each mode and then combined using the weights.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = IntervalMDPAbstractions","category":"page"},{"location":"#IntervalMDPAbstractions","page":"Home","title":"IntervalMDPAbstractions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IntervalMDPAbstractions.jl is Julia package for verifying stochastic systems and synthesizing correct-by-construction controllers via abstraction-based techniques with IMDP-inspired target models. It provides a set of abstraction methods for different types of stochastic systems (linear, non-linear, uncertain piece-wise affine, Gaussian processes, and stochastically switched systems) to Interval Markov Decision Processes (IMDPs), orthogonally decoupled IMDPs (odIMDPs), and mixtures of odIMDPs. We refer to [1, 2] for more details on the target models and abstraction process.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is built on top of IntervalMDP.jl, which provides a set of structs to model the IMDP, odIMDP, etc. along with methods for verifying and synthesizing controllers using value iteration.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is work-in-progress and the API is subject to change, as we discover what the most intuitive and fast interface is. The package is not yet registered in the Julia package registry, but can be installed directly from the GitHub repository. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package requires Julia v1.10 or later. Refer to the official documentation on how to install it for your system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install IntervalMDPAbstractions.jl, use the following command inside Julia's REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(url=\"https://github.com/Zinoex/IntervalMDPAbstractions.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1] Mathiesen, Frederik Baymler, Sofie Haesaert, and Luca Laurenti. \"Scalable control synthesis for stochastic systems via structural IMDP abstractions.\" arXiv preprint arXiv:2411.11803 (2024).","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] Cauchi, Nathalie, et al. \"Efficiency through uncertainty: Scalable formal synthesis for stochastic hybrid systems.\" Proceedings of the 22nd ACM international conference on hybrid systems: computation and control. 2019.","category":"page"},{"location":"reference/abstractions/#Abstractions","page":"Abstractions","title":"Abstractions","text":"","category":"section"},{"location":"reference/abstractions/","page":"Abstractions","title":"Abstractions","text":"To build an abstraction, in addition to the definition of the system dynamics and the specification,  we also need to define select inputs and partition the state space/region of interest. Since there are multiple options for both, we wrap them as input and state abstractions, such that the abstraction method to build the finite-state abstractions can ignore the details of the choice of input and state partitioning.","category":"page"},{"location":"reference/abstractions/#Input-abstractions","page":"Abstractions","title":"Input abstractions","text":"","category":"section"},{"location":"reference/abstractions/","page":"Abstractions","title":"Abstractions","text":"InputAbstraction\nInputGridSplit\nInputLinRange\nInputDiscrete\ninputs\nnuminputs","category":"page"},{"location":"reference/abstractions/#IntervalMDPAbstractions.InputAbstraction","page":"Abstractions","title":"IntervalMDPAbstractions.InputAbstraction","text":"InputAbstraction\n\nAbstract type for input abstractions.\n\n\n\n\n\n","category":"type"},{"location":"reference/abstractions/#IntervalMDPAbstractions.InputGridSplit","page":"Abstractions","title":"IntervalMDPAbstractions.InputGridSplit","text":"InputGridSplit\n\nInput abstraction for splitting the input space into a grid.\n\n\n\n\n\n","category":"type"},{"location":"reference/abstractions/#IntervalMDPAbstractions.InputLinRange","page":"Abstractions","title":"IntervalMDPAbstractions.InputLinRange","text":"InputLinRange\n\nInput abstraction for points on a grid of the input space.\n\n\n\n\n\n","category":"type"},{"location":"reference/abstractions/#IntervalMDPAbstractions.InputDiscrete","page":"Abstractions","title":"IntervalMDPAbstractions.InputDiscrete","text":"InputDiscrete\n\nInput abstraction for a set of discrete points in the input space.\n\n\n\n\n\n","category":"type"},{"location":"reference/abstractions/#IntervalMDPAbstractions.inputs","page":"Abstractions","title":"IntervalMDPAbstractions.inputs","text":"inputs(input::InputAbstraction)\n\nReturn the set of inputs of a given input abstraction.\n\n\n\n\n\n","category":"function"},{"location":"reference/abstractions/#IntervalMDPAbstractions.numinputs","page":"Abstractions","title":"IntervalMDPAbstractions.numinputs","text":"numinputs(input::InputAbstraction)\n\nReturn the number of inputs, i.e. the size of the set of inputs, of a given input abstraction.\n\n\n\n\n\n","category":"function"},{"location":"reference/abstractions/","page":"Abstractions","title":"Abstractions","text":"To define a new input abstraction, introduce a new struct type that inherits from InputAbstraction and implements inputs and numinputs methods. The inputs method should return the set of inputs (set-based, singletons, or discrete) and the numinputs should return the number of inputs in the set.","category":"page"},{"location":"reference/abstractions/#State-abstractions","page":"Abstractions","title":"State abstractions","text":"","category":"section"},{"location":"reference/abstractions/","page":"Abstractions","title":"Abstractions","text":"StateAbstraction\nStateUniformGridSplit\nregions\nnumregions\nstatespace","category":"page"},{"location":"reference/abstractions/#IntervalMDPAbstractions.StateAbstraction","page":"Abstractions","title":"IntervalMDPAbstractions.StateAbstraction","text":"StateAbstraction\n\nAbstract type for state abstractions.\n\n\n\n\n\n","category":"type"},{"location":"reference/abstractions/#IntervalMDPAbstractions.StateUniformGridSplit","page":"Abstractions","title":"IntervalMDPAbstractions.StateUniformGridSplit","text":"StateUniformGridSplit\n\nState abstraction for splitting the state space into a uniform grid.\n\n\n\n\n\n","category":"type"},{"location":"reference/abstractions/#IntervalMDPAbstractions.regions","page":"Abstractions","title":"IntervalMDPAbstractions.regions","text":"regions(state::StateUniformGridSplit)\n\nReturn the regions of the state abstraction.\n\n\n\n\n\n","category":"function"},{"location":"reference/abstractions/#IntervalMDPAbstractions.numregions","page":"Abstractions","title":"IntervalMDPAbstractions.numregions","text":"numregions(state::StateUniformGridSplit)\n\nReturn the number of regions of the state abstraction.\n\n\n\n\n\n","category":"function"},{"location":"reference/abstractions/#IntervalMDPAbstractions.statespace","page":"Abstractions","title":"IntervalMDPAbstractions.statespace","text":"statespace(state::StateUniformGridSplit)\n\nReturn the state space of the state abstraction. This should must be a hyperrectangle and should be equal to the union of the regions.\n\n\n\n\n\n","category":"function"},{"location":"reference/abstractions/","page":"Abstractions","title":"Abstractions","text":"Right now, we only support state abstractions that are based on a uniform grid split of the state space. However, one can easily imagine a non-uniform grid or a refinement-based partitioning for heterogenous abstractions. To implement such a state abstraction, define a new struct type that inherits from StateAbstraction and implements regions, numregions, and statespace methods.","category":"page"},{"location":"reference/abstractions/#Target-models","page":"Abstractions","title":"Target models","text":"","category":"section"},{"location":"reference/abstractions/","page":"Abstractions","title":"Abstractions","text":"IMDPTarget\nSparseIMDPTarget\nOrthogonalIMDPTarget\nSparseOrthogonalIMDPTarget\nMixtureIMDPTarget\nSparseMixtureIMDPTarget","category":"page"},{"location":"reference/abstractions/#IntervalMDPAbstractions.IMDPTarget","page":"Abstractions","title":"IntervalMDPAbstractions.IMDPTarget","text":"IMDPTarget\n\nThe traditional target for IMDP abstractions. This is a standard IMDP where each region in the abstraction corresponds to a state in the IMDP with one additional state for transitions to outside the partitioned region.\n\n\n\n\n\n","category":"type"},{"location":"reference/abstractions/#IntervalMDPAbstractions.SparseIMDPTarget","page":"Abstractions","title":"IntervalMDPAbstractions.SparseIMDPTarget","text":"SparseIMDPTarget\n\nSimilar to IMDPTarget, but uses a sparse matrix to represent the transition probabilities.\n\n\n\n\n\n","category":"type"},{"location":"reference/abstractions/#IntervalMDPAbstractions.OrthogonalIMDPTarget","page":"Abstractions","title":"IntervalMDPAbstractions.OrthogonalIMDPTarget","text":"OrthogonalIMDPTarget\n\nA target for IMDP abstractions where, for each source state, the transition probabilities are orthogonally decomposed [1]. One state is appended along each axis to capture the transitions to outside the partitioned region. \n\nBenefits compared to IMDPTarget include less memory usage, faster computation of the transition probabilities and value iteration, and tighter uncertainty set (see [1] for a proof).\n\n[1] Mathiesen, Frederik Baymler, Sofie Haesaert, and Luca Laurenti. \"Scalable control synthesis for stochastic systems via structural IMDP abstractions.\" arXiv preprint arXiv:2411.11803 (2024).\n\n\n\n\n\n","category":"type"},{"location":"reference/abstractions/#IntervalMDPAbstractions.SparseOrthogonalIMDPTarget","page":"Abstractions","title":"IntervalMDPAbstractions.SparseOrthogonalIMDPTarget","text":"SparseOrthogonalIMDPTarget\n\nSimilar to OrthogonalIMDPTarget, but uses a sparse matrix to represent the transition probabilities.\n\n\n\n\n\n","category":"type"},{"location":"reference/abstractions/#IntervalMDPAbstractions.MixtureIMDPTarget","page":"Abstractions","title":"IntervalMDPAbstractions.MixtureIMDPTarget","text":"MixtureIMDPTarget\n\nA target for IMDP abstractions where, for each source state, the transition probabilities are decomposed as a mixture [1]. One state is appended along each axis to capture the transitions to outside the partitioned region. \n\nBenefits compared to IMDPTarget include less memory usage and faster computation of the transition probabilities and value iteration.\n\n[1] Mathiesen, Frederik Baymler, Sofie Haesaert, and Luca Laurenti. \"Scalable control synthesis for stochastic systems via structural IMDP abstractions.\" arXiv preprint arXiv:2411.11803 (2024).\n\n\n\n\n\n","category":"type"},{"location":"reference/abstractions/#IntervalMDPAbstractions.SparseMixtureIMDPTarget","page":"Abstractions","title":"IntervalMDPAbstractions.SparseMixtureIMDPTarget","text":"SparseMixtureIMDPTarget\n\nSimilar to MixtureIMDPTarget, but uses a sparse matrix to represent the transition probabilities.\n\n\n\n\n\n","category":"type"},{"location":"reference/abstractions/#Constructing-finite-state-abstractions","page":"Abstractions","title":"Constructing finite-state abstractions","text":"","category":"section"},{"location":"reference/abstractions/","page":"Abstractions","title":"Abstractions","text":"abstraction","category":"page"},{"location":"reference/abstractions/#IntervalMDPAbstractions.abstraction","page":"Abstractions","title":"IntervalMDPAbstractions.abstraction","text":"abstraction(prob, state_abstraction::StateUniformGridSplit, input_abstraction, target_model::AbstractIMDPTarget)\n\nConstruct an abstraction of a system and a specification under a uniform grid partitioning of the state space with an arbitrary input abstraction and an IMDP as the target model.\n\nThe argument prob contains both the system and the specification. The type of the system determines how the transition probability bounds are computed. The resulting IMDP has numregions(state_abstraction) + 1 states, where the last state is an absorbing state, representing transitioning to outside the partitioned region. This absorbing state is implicitly encoded in the ambiguity sets, i.e. not stored and automatically handled by IntervalMDP.jl.\n\nThe specification is converted based on the state_abstraction and target_model arguments in addition to whether the specification is pessimistic or optimistic. To encode the specification, at least one avoid state is required, i.e. the last, absorbing state. As a consequence, (concrete) reachability specifications are converted to (abstract) reach-avoid specifications with the last state as the avoid state.\n\nReturns mdp and spec as the abstracted IMDP and the converted specification, respectively.\n\n\n\n\n\nabstraction(prob, state_abstraction::StateUniformGridSplit, input_abstraction, target_model::AbstractOrthogonalIMDPTarget)\n\nConstruct an abstraction of a system and a specification under a uniform grid partitioning of the state space with an arbitrary input abstraction and an orthogonal IMDP as the target model.\n\nThe argument prob contains both the system and the specification. The type of the system determines how the marginal transition probability bounds are computed. The resulting orthogonal IMDP has IntervalMDPAbstractions.splits(state_abstraction) .+ 1 states along each axis,  where the last state along each axis is an absorbing state, representing transitioning to outside the partitioned region. This absorbing state for each axis is implicitly encoded in the ambiguity sets, i.e. not stored and automatically handled by IntervalMDP.jl.\n\nThe specification is converted based on the state_abstraction and target_model arguments in addition to whether the specification is pessimistic or optimistic. To encode the specification, at least one avoid state is required, i.e. the last, absorbing state. As a consequence, (concrete) reachability specifications are converted to (abstract) reach-avoid specifications with the last state as the avoid state.\n\nReturns mdp and spec as the abstracted IMDP and the converted specification, respectively.\n\n\n\n\n\nabstraction(prob, state_abstraction::StateUniformGridSplit, input_abstraction, target_model::AbstractMixtureIMDPTarget)\n\nConstruct an abstraction of a system and a specification under a uniform grid partitioning of the state space with an arbitrary input abstraction and a mixture of orthogonal IMDPs as the target model.\n\nThe argument prob contains both the system and the specification. The type of the system determines how the marginal mixture transition probability bounds are computed. The resulting mixture IMDP has IntervalMDPAbstractions.splits(state_abstraction) .+ 1 states along each axis,  where the last state along each axis is an absorbing state, representing transitioning to outside the partitioned region. This absorbing state for each axis is implicitly encoded in the ambiguity sets, i.e. not stored and automatically handled by IntervalMDP.jl.\n\nThe specification is converted based on the state_abstraction and target_model arguments in addition to whether the specification is pessimistic or optimistic. To encode the specification, at least one avoid state is required, i.e. the last, absorbing state. As a consequence, (concrete) reachability specifications are converted to (abstract) reach-avoid specifications with the last state as the avoid state.\n\nReturns mdp and spec as the abstracted IMDP and the converted specification, respectively.\n\n\n\n\n\n","category":"function"},{"location":"reference/specifications/#Specification","page":"Specifications","title":"Specification","text":"","category":"section"},{"location":"reference/specifications/","page":"Specifications","title":"Specifications","text":"FiniteTimeRegionReachability\nInfiniteTimeRegionReachability\nFiniteTimeRegionReachAvoid\nInfiniteTimeRegionReachAvoid\nFiniteTimeRegionSafety\nInfiniteTimeRegionSafety\nreach\navoid\ndim","category":"page"},{"location":"reference/specifications/#IntervalMDPAbstractions.FiniteTimeRegionReachability","page":"Specifications","title":"IntervalMDPAbstractions.FiniteTimeRegionReachability","text":"FiniteTimeRegionReachability\n\nA struct representing a finite-time reachability property.\n\n\n\n\n\n","category":"type"},{"location":"reference/specifications/#IntervalMDPAbstractions.InfiniteTimeRegionReachability","page":"Specifications","title":"IntervalMDPAbstractions.InfiniteTimeRegionReachability","text":"InfiniteTimeRegionReachability\n\nA struct representing a infinite-time reachability property.\n\n\n\n\n\n","category":"type"},{"location":"reference/specifications/#IntervalMDPAbstractions.FiniteTimeRegionReachAvoid","page":"Specifications","title":"IntervalMDPAbstractions.FiniteTimeRegionReachAvoid","text":"FiniteTimeRegionReachAvoid\n\nA struct representing a finite-time reach-avoid property.\n\n\n\n\n\n","category":"type"},{"location":"reference/specifications/#IntervalMDPAbstractions.InfiniteTimeRegionReachAvoid","page":"Specifications","title":"IntervalMDPAbstractions.InfiniteTimeRegionReachAvoid","text":"InfiniteTimeRegionReachAvoid\n\nA struct representing a infinite-time reach-avoid property.\n\n\n\n\n\n","category":"type"},{"location":"reference/specifications/#IntervalMDPAbstractions.FiniteTimeRegionSafety","page":"Specifications","title":"IntervalMDPAbstractions.FiniteTimeRegionSafety","text":"FiniteTimeRegionSafety\n\nA struct representing a finite-time safety property.\n\n\n\n\n\n","category":"type"},{"location":"reference/specifications/#IntervalMDPAbstractions.InfiniteTimeRegionSafety","page":"Specifications","title":"IntervalMDPAbstractions.InfiniteTimeRegionSafety","text":"InfiniteTimeRegionSafety\n\nA struct representing a infinite-time safety property.\n\n\n\n\n\n","category":"type"},{"location":"reference/specifications/#IntervalMDPAbstractions.reach","page":"Specifications","title":"IntervalMDPAbstractions.reach","text":"reach\n\nReturn the reach region of a reachability or reach-avoid property.\n\n\n\n\n\n","category":"function"},{"location":"reference/specifications/#IntervalMDPAbstractions.avoid","page":"Specifications","title":"IntervalMDPAbstractions.avoid","text":"avoid\n\nReturn the avoid region of a reach-avoid or safety property.\n\n\n\n\n\n","category":"function"},{"location":"reference/specifications/#IntervalMDPAbstractions.dim","page":"Specifications","title":"IntervalMDPAbstractions.dim","text":"dim\n\nReturn the dimension of the reach and avoid regions of a regional property.\n\n\n\n\n\n","category":"function"},{"location":"reference/specifications/#Abstraction-problem","page":"Specifications","title":"Abstraction problem","text":"","category":"section"},{"location":"reference/specifications/","page":"Specifications","title":"Specifications","text":"AbstractionProblem\nsystem\nspecification","category":"page"},{"location":"reference/specifications/#IntervalMDPAbstractions.AbstractionProblem","page":"Specifications","title":"IntervalMDPAbstractions.AbstractionProblem","text":"AbstractionProblem\n\nA struct of a system and a specification to be used in the abstraction process.\n\n\n\n\n\n","category":"type"},{"location":"reference/specifications/#IntervalMDPAbstractions.system","page":"Specifications","title":"IntervalMDPAbstractions.system","text":"system\n\nReturn the system of an abstraction problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/specifications/#IntervalMDPAbstractions.specification","page":"Specifications","title":"IntervalMDPAbstractions.specification","text":"specification\n\nReturn the specification of an abstraction problem.\n\n\n\n\n\n","category":"function"}]
}
